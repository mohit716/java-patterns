lets see what problem factory solves by seeing some code with factory and without factory:

================================================================================
PART 1: END-TO-END WITHOUT FACTORY (the problem)
================================================================================

Scenario: A small app with three features that need animals:
  - PetShop: creates animals to sell
  - Game: creates animals as characters
  - SoundBoard: creates animals to play sounds

--- Code scattered across 3 places ---

// File: PetShop.java
class PetShop {
    void addPet(String type) {
        if (type.equalsIgnoreCase("dog")) {
            Animal a = new Dog();   // direct dependency on Dog
            display(a);
        } else if (type.equalsIgnoreCase("cat")) {
            Animal a = new Cat();   // direct dependency on Cat
            display(a);
        } else {
            throw new IllegalArgumentException("Unknown: " + type);
        }
    }
}

// File: Game.java
class Game {
    void spawnCharacter(String type) {
        if (type.equalsIgnoreCase("dog")) {
            Animal a = new Dog();   // same if/else logic duplicated
            addToScene(a);
        } else if (type.equalsIgnoreCase("cat")) {
            Animal a = new Cat();
            addToScene(a);
        } else {
            throw new IllegalArgumentException("Unknown: " + type);
        }
    }
}

// File: SoundBoard.java
class SoundBoard {
    void playSound(String type) {
        if (type.equalsIgnoreCase("dog")) {
            Animal a = new Dog();   // same logic again
            a.speak();
        } else if (type.equalsIgnoreCase("cat")) {
            Animal a = new Cat();
            a.speak();
        } else {
            throw new IllegalArgumentException("Unknown: " + type);
        }
    }
}

--- Problem 1: Adding a new type (Bird) is painful ---
You must change EVERY file that creates animals:
  - PetShop.java  → add "bird" branch and new Bird()
  - Game.java     → add "bird" branch and new Bird()
  - SoundBoard.java → add "bird" branch and new Bird()

Same if/else and same "unknown type" handling copy-pasted in 3 places.
Risk: forget one file → inconsistent behaviour or bugs.

--- Problem 2: Creation logic gets complex ---
Suppose Dog and Cat need setup (e.g. load config, register with a manager):

    Animal a = new Dog();
    a.loadConfig("dog.json");      // every client must remember this
    AnimalRegistry.register(a);    // and this

Now every place that does "new Dog()" or "new Cat()" must repeat this.
If the rules change (e.g. config path, or we add caching), you update N files.

--- Problem 3: Client is tightly coupled to concrete classes ---
PetShop, Game, SoundBoard all import Dog, Cat (and later Bird, etc.).
They "know" the full list of concrete types. Any new type = more imports
and more branches in every client. Testing is harder: you can't easily
swap a real Dog for a MockDog without changing every call site.

--- Problem 4: No single place for "what types exist" ---
There is no one class that defines "we support dog, cat, bird". The
knowledge is spread. New developers (or you in 6 months) have to grep
for "new Dog()" / "new Cat()" to find all creation points.

================================================================================
PART 2: END-TO-END WITH FACTORY (the solution)
================================================================================

Same scenario: PetShop, Game, SoundBoard need animals. This time they
ask a factory; they never say "new Dog()" or "new Cat()".

--- Single place: AnimalFactory ---

// File: AnimalFactory.java
class AnimalFactory {
    public static Animal create(String type) {
        String t = type.trim().toLowerCase();
        if (t.equals("dog")) return new Dog();
        if (t.equals("cat")) return new Cat();
        if (t.equals("bird")) return new Bird();
        throw new IllegalArgumentException("Unknown animal: " + type);
    }
}

--- Clients become simple and identical in style ---

// File: PetShop.java
class PetShop {
    void addPet(String type) {
        Animal a = AnimalFactory.create(type);   // one line
        display(a);
    }
}

// File: Game.java
class Game {
    void spawnCharacter(String type) {
        Animal a = AnimalFactory.create(type);
        addToScene(a);
    }
}

// File: SoundBoard.java
class SoundBoard {
    void playSound(String type) {
        Animal a = AnimalFactory.create(type);
        a.speak();
    }
}

--- Benefit 1: Adding Bird = one place ---
Only AnimalFactory.create() changes. PetShop, Game, SoundBoard stay
unchanged. No duplicated if/else, no risk of forgetting a file.

--- Benefit 2: Creation logic in one place ---
When Dog/Cat need config or registration:

    public static Animal create(String type) {
        String t = type.trim().toLowerCase();
        Animal a;
        if (t.equals("dog")) a = new Dog();
        else if (t.equals("cat")) a = new Cat();
        else if (t.equals("bird")) a = new Bird();
        else throw new IllegalArgumentException("Unknown: " + type);
        a.loadConfig(t + ".json");
        AnimalRegistry.register(a);
        return a;
    }

All clients automatically get the same behaviour. Change the rules once.

--- Benefit 3: Clients depend only on Animal + Factory ---
PetShop, Game, SoundBoard import Animal and AnimalFactory only. They
don't import Dog, Cat, Bird. New types don't force client changes.
For tests, you can pass a different factory (or mock the factory) so
clients stay the same.

--- Benefit 4: One place that defines "what we create" ---
AnimalFactory is the single list of supported types and how they are
created. Easy to document, easy to extend, easy to find.

================================================================================
SUMMARY
================================================================================

Without factory:
  - Many places create objects with duplicated type-checking and creation.
  - New type or new creation rules → edit many files.
  - Clients are coupled to every concrete class (Dog, Cat, Bird, ...).

With factory:
  - One place (the factory) decides which object to create and how.
  - New type or new rules → change only the factory; clients stay simple.
  - Clients depend on the interface (Animal) and the factory, not on
    concrete classes.

Factory pattern = centralize "which object to create" so the rest of
the code stays simple and decoupled from concrete types.
