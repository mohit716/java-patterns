lets see what problem factory solves by seeing some code with factory and without factory:

--- WITHOUT FACTORY (the problem) ---
The client creates objects directly and depends on concrete classes:

    Animal a1 = new Dog();
    Animal a2 = new Cat();

Problems:
- Client code is tightly coupled to Dog, Cat, etc. (must import/know every concrete type).
- Adding a new type (e.g. Bird) means changing every place that does "new Dog()" / "new Cat()".
- Creation logic (e.g. validation, config) is scattered and duplicated.

--- WITH FACTORY (the solution) ---
The client asks the factory for an object by type; it never says "new Dog()" or "new Cat()":

    Animal a1 = AnimalFactory.create("dog");
    Animal a2 = AnimalFactory.create("cat");

Benefits:
- Client depends only on the Animal interface and the factory, not on Dog/Cat.
- New types (e.g. Bird) are added in one place: AnimalFactory.create().
- Creation rules (validation, defaults, which class to use) live in one place.
--- SUMMARY ---
Factory Pattern = centralize "which object to create" so the client stays simple and decoupled from concrete classes.
